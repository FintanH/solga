-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Simple typesafe web routing
--   
--   Simple typesafe web routing
@package solga
@version 0.1.0.0

module Solga

-- | Serve a <a>Router</a> with Solga, returning <a>SolgaError</a>s as HTTP
--   responses.
serve :: Router r => r -> Application

-- | Serve a <a>Router</a> with Solga, throwing <a>SolgaError</a>s.
serveThrow :: Router r => r -> Application

-- | Compose routers. This is just type application, ie.: <tt>Foo :&gt; Bar
--   :&gt; Baz == Foo (Bar Baz)</tt>
type (:>) f g = f g

-- | Match a path, segment, e.g <tt>"foo" <a>/&gt;</a> <a>JSON</a> Bar</tt>
type (/>) seg g = Seg seg :> g

-- | Handle a <a>GET</a> request and produce a <a>JSON</a> response, with
--   <a>IO</a>.
type Get a = Endpoint "GET" (JSON a)

-- | Handle a <a>POST</a> request and produce a <a>JSON</a> response, with
--   <a>IO</a>.
type Post a = Endpoint "POST" (JSON a)

-- | Return a given JSON object
newtype JSON a
JSON :: a -> JSON a
[jsonResponse] :: JSON a -> a

-- | Serve a given WAI <a>Application</a>.
newtype Raw
Raw :: Application -> Raw
[rawApp] :: Raw -> Application

-- | Serve a given WAI <a>Response</a>.
newtype RawResponse
RawResponse :: Response -> RawResponse
[rawResponse] :: RawResponse -> Response

-- | Only accept the end of a path.
newtype End next
End :: next -> End next
[endNext] :: End next -> next

-- | Produce a response with <a>IO</a>.
newtype WithIO next
WithIO :: IO next -> WithIO next
[withIONext] :: WithIO next -> IO next

-- | Match a constant directory in the path.
--   
--   When specifying APIs, use the <a>/&gt;</a> combinator to specify
--   sub-paths: <tt>"foo" <a>/&gt;</a> <a>JSON</a> Bar</tt>
newtype Seg (seg :: Symbol) next
Seg :: next -> Seg next
[segNext] :: Seg next -> next

-- | Match any of a set of path segments.
data OneOfSegs (segs :: [Symbol]) next
OneOfSegs :: next -> OneOfSegs next
[oneOfSegsNext] :: OneOfSegs next -> next

-- | The class of types that can be parsed from a path segment.
class FromSegment a
fromSegment :: FromSegment a => Text -> Maybe a

-- | Capture a path segment and pass it on.
newtype Capture a next
Capture :: (a -> next) -> Capture a next
[captureNext] :: Capture a next -> a -> next

-- | Accepts requests with a certain method.
newtype Method (method :: Symbol) next
Method :: next -> Method next
[methodNext] :: Method next -> next

-- | Set extra headers on responses. Existing headers will be overriden if
--   specified here.
data ExtraHeaders next
ExtraHeaders :: ResponseHeaders -> next -> ExtraHeaders next
[extraHeaders] :: ExtraHeaders next -> ResponseHeaders
[extraHeadersNext] :: ExtraHeaders next -> next

-- | Prevent caching for sub-routers.
newtype NoCache next
NoCache :: next -> NoCache next
[noCacheNext] :: NoCache next -> next

-- | Parse a JSON request body.
newtype ReqBodyJSON a next
ReqBodyJSON :: (a -> next) -> ReqBodyJSON a next
[reqBodyJSONNext] :: ReqBodyJSON a next -> a -> next

-- | A parsed "multipart/form-data" request.
type MultiPartData = ([Param], [File FilePath])

-- | Accept a "multipart/form-data" request. Files will be stored in a
--   temporary directory and will be deleted automatically after the
--   request is processed.
data ReqBodyMultipart a next
ReqBodyMultipart :: (MultiPartData -> Either String a) -> (a -> next) -> ReqBodyMultipart a next
[reqMultiPartParse] :: ReqBodyMultipart a next -> MultiPartData -> Either String a
[reqMultiPartNext] :: ReqBodyMultipart a next -> a -> next

-- | Useful synonym for dynamic endpoints: accept requests with a given
--   method, compute a JSON response in <a>IO</a> and don't cache.
type Endpoint method a = End :> (NoCache :> (Method method :> (WithIO :> a)))

-- | Try to route with <tt>left</tt>, or try to route with <tt>right</tt>.
data (:<|>) left right
(:<|>) :: left -> right -> (:<|>) left right
[altLeft] :: (:<|>) left right -> left
[altRight] :: (:<|>) left right -> right

-- | Most <a>Router</a>s are really just newtypes. By using <a>brief</a>,
--   you can construct trees of <a>Router</a>s by providing only their
--   inner types, much like Servant.
class Abbreviated a where type family Brief a :: * Brief a = a brief = id
brief :: Abbreviated a => Brief a -> a

-- | A <a>Router</a>-related exception with a corresponding HTTP error
--   code.
data SolgaError

-- | Create a <tt>400 Bad Request</tt> error with a given message.
badRequest :: Text -> SolgaError

-- | Create a <tt>404 Not Found</tt> error with a given message.
notFound :: Text -> SolgaError

-- | Routers are the basic typeclass of Solga: their types describe what
--   type of requests they accept, and their values describe how to handle
--   them.
--   
--   You can use <a>Generic</a> to get free instance of <a>Router</a> for
--   any data type with one constructor and <a>Router</a>s as fields. The
--   fields will be considered alternatives, as if you wrote
--   <a>:&lt;|&gt;</a> between them.
class Router r where tryRoute = tryRouteNext (from :: r -> Rep r ())

-- | Given a request, if the router supports the given request return a
--   function that constructs a response with a concrete router.
tryRoute :: Router r => Request -> Maybe (r -> Responder)

-- | The right hand side of <tt>Application</tt>. <tt>Request</tt> is
--   already known.
type Responder = (Response -> IO ResponseReceived) -> IO ResponseReceived

-- | Try to route using a type <tt>r</tt> by providing a function to turn
--   it into a <a>Router</a> <tt>r'</tt>. Useful for passing routing on to
--   the next step.
tryRouteNext :: Router r' => (r -> r') -> Request -> Maybe (r -> Responder)

-- | Like <a>tryRouteNext</a> but in <a>IO</a>.
tryRouteNextIO :: Router r' => (r -> IO r') -> Request -> Maybe (r -> Responder)
instance GHC.Show.Show Solga.SolgaError
instance GHC.Classes.Ord Solga.SolgaError
instance GHC.Classes.Eq Solga.SolgaError
instance GHC.Show.Show a => GHC.Show.Show (Solga.JSON a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Solga.JSON a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Solga.JSON a)
instance GHC.Show.Show next => GHC.Show.Show (Solga.Method method next)
instance GHC.Classes.Ord next => GHC.Classes.Ord (Solga.Method method next)
instance GHC.Classes.Eq next => GHC.Classes.Eq (Solga.Method method next)
instance (GHC.Show.Show left, GHC.Show.Show right) => GHC.Show.Show (left Solga.:<|> right)
instance (GHC.Classes.Ord left, GHC.Classes.Ord right) => GHC.Classes.Ord (left Solga.:<|> right)
instance (GHC.Classes.Eq left, GHC.Classes.Eq right) => GHC.Classes.Eq (left Solga.:<|> right)
instance GHC.Show.Show next => GHC.Show.Show (Solga.Seg seg next)
instance GHC.Classes.Ord next => GHC.Classes.Ord (Solga.Seg seg next)
instance GHC.Classes.Eq next => GHC.Classes.Eq (Solga.Seg seg next)
instance Solga.Router r => Solga.Router (GHC.Generics.K1 i r p)
instance Solga.Router (f p) => Solga.Router (GHC.Generics.M1 i c f p)
instance Solga.Router Solga.Raw
instance Solga.Router Solga.RawResponse
instance Solga.Router next => Solga.Router (Solga.End next)
instance (GHC.TypeLits.KnownSymbol seg, Solga.Router next) => Solga.Router (Solga.Seg seg next)
instance (Solga.Router left, Solga.Router right) => Solga.Router (left Solga.:<|> right)
instance (GHC.TypeLits.KnownSymbol seg, Solga.Router next, Solga.Router (Solga.OneOfSegs segs next)) => Solga.Router (Solga.OneOfSegs (seg : segs) next)
instance Solga.Router next => Solga.Router (Solga.OneOfSegs '[] next)
instance Solga.FromSegment Data.Text.Internal.Text
instance (Solga.FromSegment a, Solga.Router next) => Solga.Router (Solga.Capture a next)
instance (GHC.TypeLits.KnownSymbol method, Solga.Router next) => Solga.Router (Solga.Method method next)
instance Data.Aeson.Types.Class.ToJSON a => Solga.Router (Solga.JSON a)
instance Solga.Router next => Solga.Router (Solga.ExtraHeaders next)
instance Solga.Router next => Solga.Router (Solga.NoCache next)
instance (Data.Aeson.Types.Class.FromJSON a, Solga.Router next) => Solga.Router (Solga.ReqBodyJSON a next)
instance Solga.Router next => Solga.Router (Solga.WithIO next)
instance Solga.Router next => Solga.Router (Solga.ReqBodyMultipart a next)
instance Solga.Abbreviated Solga.Raw
instance Solga.Abbreviated Solga.RawResponse
instance Solga.Abbreviated next => Solga.Abbreviated (Solga.End next)
instance Solga.Abbreviated next => Solga.Abbreviated (Solga.Seg seg next)
instance (Solga.Abbreviated left, Solga.Abbreviated right) => Solga.Abbreviated (left Solga.:<|> right)
instance Solga.Abbreviated next => Solga.Abbreviated (Solga.OneOfSegs segs next)
instance Solga.Abbreviated next => Solga.Abbreviated (Solga.Capture a next)
instance Solga.Abbreviated next => Solga.Abbreviated (Solga.Method method next)
instance Solga.Abbreviated (Solga.JSON a)
instance Solga.Abbreviated (Solga.ExtraHeaders next)
instance Solga.Abbreviated next => Solga.Abbreviated (Solga.NoCache next)
instance Solga.Abbreviated next => Solga.Abbreviated (Solga.ReqBodyJSON a next)
instance Solga.Abbreviated next => Solga.Abbreviated (Solga.WithIO next)
instance Solga.Abbreviated (Solga.ReqBodyMultipart a next)
instance (Solga.Router (left p), Solga.Router (right p)) => Solga.Router ((GHC.Generics.:*:) left right p)
instance GHC.Exception.Exception Solga.SolgaError
